<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Computability Part 8: Lambda Calculus &mdash; Blog</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="../../../static/light.css" type="text/css">
<link rel="stylesheet" href="../../../static/pygments.css" type="text/css">
<link rel="shortcut icon" href="../../../static/icon.ico" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<header><span>October 14, 2022</span></header>
<article>
<h1>Computability Part 8: Lambda Calculus</h1>

<p>In the previous posts, we dug deeper into one particular model of computation,
starting with Turing Machines in <a href="https://vladris.com/blog/2022/04/03/computability-part-2-turing-machines.html">part 2</a>,
to the von Neumann computer architecture in <a href="https://vladris.com/blog/2022/07/31/computability-part-6-von-neumann-architecture.html">part 6</a>,
to some of the implementation practicalities of machines - physical or virtual
- in <a href="https://vladris.com/blog/2022/09/02/computability-part-7-machine-implementation-practicalities.html">part 7</a>.</p>

<p>We&#39;ll switch gears and cover another computational model this time around:
<em>lambda calculus</em>. Lambda calculus was developed by Alonzo Church around the
same time Alan Turing was proposing the Turing machine as a universal model for
computation. The <em>Church-Turing thesis</em><sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> proves the equivalence between the
two models - anything a Turing machine can compute can also be computed by
lambda calculus.</p>

<p>Formally:</p>

<blockquote>
<p>Lambda calculus consists of lambda terms and reductions applied to lambda
terms.</p>

<p>The lambda terms are built with the following rules, where \(\Lambda\) is the
set of all possible lambda terms:</p>

<ul>
<li><em>Variables</em>, like \(x\), are lambda terms. \(x \in \Lambda\).</li>
<li><em>Abstractions</em>, \((\lambda x.M)\). This is a function definition where \(M\) is
a lambda term and \(x\) becomes <em>bound</em> in the expression. For \(x \in \Lambda\)
and \(M \in \Lambda\), \((\lambda x.M) \in \Lambda\). </li>
<li><em>Applications</em>, \((M \space N)\). This applies the function \(M\) to the
argument \(N\), where \(M\) and \(N\) are lambda terms. For \(M \in \Lambda\) and \(N
\in \Lambda\), \((M \space N) \in \Lambda\).</li>
</ul>

<p>If a term \(y\) appears in \(M\) but is not bound, then \(y\) is <em>free</em> in \(M\), e.g.
for \(\lambda x.y \space x\), \(x\) is bound and \(y\) is free.
The reductions are:</p>

<ul>
<li><em>\(\alpha\)-equivalence</em>: bound variables in an expression can be renamed to
avoid collisions: \((\lambda x.M[x]) \rightarrow (\lambda y.M[y])\).</li>
<li><em>\(\beta\)-reduction</em>: bound variables in the body of an abstraction are
replaced with the argument expression: \((\lambda x.t)s \rightarrow
t[x := s]\).</li>
<li><em>\(\eta\)-reduction</em>: if \(x\) is a variable that does not appear free in the
lambda term <em>M</em>, then \(\lambda x.(M x) \rightarrow M\). This can also be
understood in terms of function equivalence: if two functions give the same
result for all arguments, then the functions are equivalent.</li>
</ul>
</blockquote>

<p>Let&#39;s look at a few simple examples in Python:</p>
<div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
</pre></div>

<p>This is the identity function expressed as a lambda abstraction. In this case,
<code>x</code> (the lambda parameter), becomes bound in the body of the lambda.</p>

<p>\(\alpha\)-equivalence:</p>
<div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span>
</pre></div>

<p>This is the same identity function, we&#39;re just using <code>y</code> instead of <code>x</code> to name
the parameter.</p>

<p>For function application, we can apply the identity function to any other lambda
term and get back that lambda term:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="p">)</span>
</pre></div>

<p>This applied the identify function <code>lambda x: x</code> to the argument <code>lambda y: y</code>,
which will give us back <code>lambda y: y</code>.</p>

<h2>Church encoding</h2>

<p>Based on the above definition, lambda calculus consists <em>exclusively</em> of lambda
terms - while <code>(lambda x: x)(10)</code> is valid Python code, applying an identity
lambda to the number <code>10</code>, lambda calculus does not have a number <code>10</code>. Enter
<em>Church encoding</em>: Alonzo Church came up with a way to encode logic values and
numbers as lambda terms.</p>

<h3>Logic</h3>

<p>Let&#39;s start with Boolean logic: <code>TRUE</code> is defined as \(T := (\lambda x.\lambda
y.x)\), <code>FALSE</code> is defined as \(F := (\lambda x.\lambda y.y)\).</p>
<div class="highlight"><pre><span></span><span class="n">TRUE</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span>
<span class="n">FALSE</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span>
</pre></div>

<p>Note with this definition, if we apply a first argument to <code>TRUE</code>, and a second
argument to the returned lambda, we always get back the first argument. For
<code>FALSE</code>, we always get back the second argument.</p>

<p>We can defined <code>IF</code> as \(IF := (\lambda x.x)\). This is the same as the identity
function.</p>
<div class="highlight"><pre><span></span><span class="n">IF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
</pre></div>

<p>This works since we defined <code>TRUE</code> to always return the first argument and
<code>FALSE</code> to always return the second argument. So when we call <code>IF(c)(x)(y)</code>,
if <code>c</code> is <code>TRUE</code>, we get back <code>x</code> (the if-branch), otherwise we get back <code>y</code>
(the else-branch).</p>

<p>We can try this out (though again this is outside of lambda calculus, we are
introducing numbers for clarity):</p>
<div class="highlight"><pre><span></span><span class="n">IF</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># This returns 1</span>
<span class="n">IF</span><span class="p">(</span><span class="n">FALSE</span><span class="p">)(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># This returns 2</span>
</pre></div>

<p>Now that we can express if-then-else, we can easily express other logic
operators. Negation is \(\lambda x.(x \space F \space T)\).</p>
<div class="highlight"><pre><span></span><span class="n">NOT</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">(</span><span class="n">FALSE</span><span class="p">)(</span><span class="n">TRUE</span><span class="p">)</span>
</pre></div>

<p>If <code>x</code> is <code>TRUE</code>, we get back the first argument, <code>FALSE</code>; if <code>x</code> is <code>FALSE</code>,
we get back the second argument, <code>TRUE</code>.</p>

<p><code>x AND y</code> can be expressed as <em>if x then y else FALSE</em>, or: \(\lambda x.\lambda
y.(x \space y \space F)\). <code>x OR y</code> can be expressed as <em>if x then TRUE else y</em>,
or \(\lambda x.\lambda y.(x \space T \space y)\).</p>
<div class="highlight"><pre><span></span><span class="n">AND</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span><span class="p">)(</span><span class="n">FALSE</span><span class="p">)</span>
<span class="n">OR</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

<p>Here are a few examples:</p>
<div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">AND</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)(</span><span class="n">TRUE</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>  <span class="c1"># prints True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">AND</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)(</span><span class="n">FALSE</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span> <span class="c1"># prints False</span>
<span class="nb">print</span><span class="p">(</span><span class="n">OR</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)(</span><span class="n">FALSE</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>  <span class="c1"># prints True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">NOT</span><span class="p">(</span><span class="n">FALSE</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>       <span class="c1"># prints True</span>
</pre></div>

<p>Using only lambda terms, we were able to implement Boolean logic! But Church
encoding goes further - we can also represent natural numbers and arithmetic
as lambda terms.</p>

<h3>Arithmetic</h3>

<p>Alonzo Church encoded numbers as applications of a function \(f\) to a term \(x\).</p>

<ul>
<li><code>0</code> means applying \(f\) 0 times to the term: \(0 := \lambda f.\lambda x.x\).</li>
<li><code>1</code> means applying \(f\) once to the term: \(1 := \lambda f.\lambda x.f x\).</li>
<li><code>2</code> means applying \(f\) twice: \(2 := \lambda f.\lambda x.f (f x)\).</li>
</ul>

<p>In general, the number <code>n</code> is represented by <code>n</code> applications of <code>f</code>: \(n :=
\lambda f.\lambda x.f (f (... (f x)) ... ))\) or \(n := \lambda f.\lambda x.
f^n(x)\).</p>

<p>In Python:</p>
<div class="highlight"><pre><span></span><span class="n">ZERO</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
<span class="n">ONE</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">TWO</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="o">...</span>
</pre></div>

<p>Note <code>ZERO</code> is the same as <code>FALSE</code>. With this definition of numbers, we can
define the successor function <code>SUCC</code> as a function that takes a number <code>n</code>
(represented with our Church encoding), the function <code>f</code>, the term <code>x</code>, and
applies <code>f</code> one more time. \(SUCC := \lambda n.\lambda f.\lambda x.f (n f x)\).</p>
<div class="highlight"><pre><span></span><span class="n">SUCC</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>We can define addition as \(PLUS := \lambda m.\lambda n.m \space SUCC \space n\).
Since we define a number as repeatedly applying a function, we express <code>m + n</code>
as applying <code>m</code> times the successor function <code>SUCC</code> to <code>n</code>.</p>
<div class="highlight"><pre><span></span><span class="n">PLUS</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">m</span><span class="p">(</span><span class="n">SUCC</span><span class="p">)(</span><span class="n">n</span><span class="p">)</span>
</pre></div>

<p>We can similarly define multiplication as applications of the <code>PLUS</code> function:</p>
<div class="highlight"><pre><span></span><span class="n">MUL</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">m</span><span class="p">(</span><span class="n">PLUS</span><span class="p">)(</span><span class="n">n</span><span class="p">)</span>
</pre></div>

<p>We&#39;ll stop here with arithmetic, but this should hopefully give you a sense of
the expressive power of lambda calculus.</p>

<h2>Combinators</h2>

<p>Some well-known lambda terms are called <em>combinators</em>:</p>

<ul>
<li>\(I\) is the identity combinator \(I := \lambda x.x\).</li>
<li>\(K\) is the constant combinator \(K := \lambda x.\lambda y.x\). When applied to
an argument \(x\), it returns a constant function \(K_x\) which returns \(x\) when
applied to any argument.</li>
<li>\(S\) is the substitution combinator \(S := \lambda x.\lambda y.\lambda z.x z
(y z)\). \(S\) takes 3 arguments, \(x\), \(y\), and \(z\), applies \(x\) to \(z\), then
applies the result of applying \(y\) to \(z\) to it.</li>
</ul>

<p>In Python:</p>
<div class="highlight"><pre><span></span><span class="n">I</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
<span class="n">K</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span>
<span class="n">S</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">x</span><span class="p">(</span><span class="n">z</span><span class="p">)(</span><span class="n">y</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
</pre></div>

<p>Turns out these 3 combinators can together express any lambda term. The SKI
combinators are the simplest <q>programming language</q> since they can express
anything expressable in lambda calculus, which we know is Turing-complete.</p>

<h3>The Y combinator</h3>

<p>Another interesting combinator is the \(Y\) combinator. In lambda calculus, there
is no way for a function to reference itself: within the body of a lambda like
<code>lambda x: ...</code> we can refer to the bound term <code>x</code>, but we can reference the
lambda itself. The implication is that we can&#39;t define, using this syntax,
self-referential functions. We can only pass functions as arguments. How can we
then implement recursion? With the \(Y\) combinator, of course.</p>

<p>Let&#39;s take an example: we can recursively define factorial as:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fact</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>This works, but note we reference <code>fact()</code> within its body. In lambda calculus
we can&#39;t do that.</p>

<p>The \(Y\) combinator is defined as \(Y := \lambda f.(\lambda x.f (x x))(\lambda
x.f (x x))\).</p>
<div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)))(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="n">z</span><span class="p">)))</span>
</pre></div>

<p>Note the Python implementation is slightly different than the mathematical
definition. This has to do with the way in which Python evaluates arguments.
We won&#39;t go into the details here, but consider this a Python implementation
detail irrelevant to the lambda calculus discussion<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>.</p>

<p>Here is a lambda version of factorial:</p>
<div class="highlight"><pre><span></span><span class="n">FACT</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p>With this definition, we pass the function to call as an argument (<code>f</code>). We can
fully express this in lambda calculus (using Church numerals, arithmetic and
logic), but we&#39;ll keep the example simple. We can then use the \(Y\) combinator
like this:</p>
<div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="n">FACT</span><span class="p">)(</span><span class="mi">5</span><span class="p">))</span>  <span class="c1"># prints 120</span>
</pre></div>

<p>This should give you an intuitive understanding of how the \(Y\) combinator
works: we pass it our function and argument, and it enables the recursion
mechanism.</p>

<p>We can similarly implement Fibonacci as:</p>
<div class="highlight"><pre><span></span><span class="n">FIB</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">Y</span><span class="p">(</span><span class="n">FIB</span><span class="p">)(</span><span class="mi">10</span><span class="p">))</span>  <span class="c1"># prints 55</span>
</pre></div>

<p>The powerful \(Y\) combinator can be used to define recursive functions in
programming languages that don&#39;t natively support recursion.</p>

<h1>Lists</h1>

<p>Let&#39;s also look at how we can express lists in lambda calculus. Let&#39;s start
with pairs. We can define a pair as \(PAIR := \lambda x.\lambda y.\lambda f.
f x y\). We can extract the first element of a pair with \(FIRST := \lambda p.
p \space T\) and the second one with \(SECOND := \lambda p.p \space F\).</p>
<div class="highlight"><pre><span></span><span class="n">PAIR</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
<span class="n">FIRST</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
<span class="n">SECOND</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">FALSE</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">FIRST</span><span class="p">(</span><span class="n">PAIR</span><span class="p">(</span><span class="mi">10</span><span class="p">)(</span><span class="mi">20</span><span class="p">)))</span>  <span class="c1"># prints 10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">SECOND</span><span class="p">(</span><span class="n">PAIR</span><span class="p">(</span><span class="mi">10</span><span class="p">)(</span><span class="mi">20</span><span class="p">)))</span> <span class="c1"># prints 20</span>
</pre></div>

<p>We can define a <code>NULL</code> value as \(NULL := \lambda x.T\) and a test for <code>NULL</code> as
\(ISNULL := \lambda p.p (\lambda x.\lambda y.FALSE)\).</p>
<div class="highlight"><pre><span></span><span class="n">NULL</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">TRUE</span>
<span class="n">ISNULL</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">FALSE</span><span class="p">)</span>
</pre></div>

<p>We can now define a linked list as either <code>NULL</code> (an empty list) or as a pair
consisting of a pair of elements - a head element and a tail list.</p>

<p>We can get the head of the list using <code>FIRST</code> and the tail using <code>SECOND</code>. Given
list \(L\), we can prepend an element \(x\) by forming the pair \((x, L)\).</p>
<div class="highlight"><pre><span></span><span class="n">HEAD</span> <span class="o">=</span> <span class="n">FIRST</span>
<span class="n">TAIL</span> <span class="o">=</span> <span class="n">SECOND</span>
<span class="n">PREPEND</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="n">PAIR</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="n">xs</span><span class="p">)</span>
</pre></div>

<p>We can build a list by prepending elements to <code>NULL</code>, and traverse it using
<code>HEAD</code> and <code>TAIL</code>:</p>
<div class="highlight"><pre><span></span><span class="c1"># Build the list [10, 20, 30]</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">PREPEND</span><span class="p">(</span><span class="mi">10</span><span class="p">)(</span><span class="n">PREPEND</span><span class="p">(</span><span class="mi">20</span><span class="p">)(</span><span class="n">PREPEND</span><span class="p">(</span><span class="mi">30</span><span class="p">)(</span><span class="n">NULL</span><span class="p">)))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">HEAD</span><span class="p">(</span><span class="n">TAIL</span><span class="p">(</span><span class="n">L</span><span class="p">)))</span> <span class="c1"># prints 20</span>
</pre></div>

<p>Appending is more interesting: if our list is represented as a pair of head and
tail, we need to <q>traverse</q> the list until we reach the end. This sounds a lot
like a recursive function: appending <code>x</code> to <code>xs</code> entails returning the pair
<code>PAIR(x, NULL)</code> if <code>xs</code> is <code>NULL</code>, else the pair <code>PAIR(HEAD(xs), APPEND(TAIL(xs,
x)))</code>. Fortunately, we just looked at the \(Y\) combinator which allows us
to express this.</p>

<p>Here is a simplified, readable implementation, using Python tuples:</p>
<div class="highlight"><pre><span></span><span class="n">_append</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> \
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">xs</span> <span class="k">else</span> <span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">])(</span><span class="n">x</span><span class="p">))</span>

<span class="n">append</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(</span><span class="n">_append</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)(</span><span class="mi">10</span><span class="p">))(</span><span class="mi">20</span><span class="p">))(</span><span class="mi">30</span><span class="p">))</span>

<span class="c1"># This will print (10, (20, (30, None)))</span>
</pre></div>

<p>We can express the same using the lambdas we defined above (<code>NULL</code>, <code>ISNULL</code>,
<code>PAIR</code>, <code>HEAD</code>, <code>TAIL</code>):</p>
<div class="highlight"><pre><span></span><span class="n">_APPEND</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">xs</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> \
    <span class="n">ISNULL</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">PAIR</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="n">NULL</span><span class="p">))</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">PAIR</span><span class="p">(</span><span class="n">HEAD</span><span class="p">(</span><span class="n">xs</span><span class="p">))(</span><span class="n">f</span><span class="p">(</span><span class="n">TAIL</span><span class="p">(</span><span class="n">xs</span><span class="p">))(</span><span class="n">x</span><span class="p">)))</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>

<span class="n">APPEND</span> <span class="o">=</span> <span class="n">Y</span><span class="p">(</span><span class="n">_APPEND</span><span class="p">)</span>

<span class="n">L</span> <span class="o">=</span> <span class="n">APPEND</span><span class="p">(</span><span class="n">APPEND</span><span class="p">(</span><span class="n">APPEND</span><span class="p">(</span><span class="n">NULL</span><span class="p">)(</span><span class="mi">10</span><span class="p">))(</span><span class="mi">20</span><span class="p">))(</span><span class="mi">30</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">HEAD</span><span class="p">(</span><span class="n">L</span><span class="p">))</span>       <span class="c1"># prints 10</span>
<span class="nb">print</span><span class="p">(</span><span class="n">HEAD</span><span class="p">(</span><span class="n">TAIL</span><span class="p">(</span><span class="n">L</span><span class="p">)))</span> <span class="c1"># prints 20</span>
</pre></div>

<p>We covered logic, arithmetic, combinators, pairs, and lists, all expressed as
lambda terms. Let&#39;s also sketch a proof of Turing completeness, like we did in
previous posts.</p>

<h2>A sketch of Turing completeness</h2>

<p>We&#39;re calling this a <q>sketch</q>, as lambda notation is not easy to read. We will
instead look at an implementation using more Python syntax than just lambdas,
but we will only use constructs which we know can be expressed in lambda
calculus.</p>

<p>As usual, we will emulate another system which we know to be Turing-complete.
In <a href="https://vladris.com/blog/2022/05/20/computability-part-3-tag-systems.html">part 3</a>
we looked at tag systems. We talked about cyclic tag systems, which can emulate
m-tag systems, which are Turing-complete. As a reminder, a cyclic tag system is
implemented as a set of binary strings (strings containing only <code>0</code>s and <code>1</code>s)
which are production rules, and we process a binary input string by popping the
head of the string and, if it is equal to <code>1</code>, appending the current production
rule to the string. We cycle through the production rules at each step. This is
the code we used in the previous post:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cyclic_tag_system</span><span class="p">(</span><span class="n">productions</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
    <span class="c1"># Keeps track of current production</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Repeat until the string is empty</span>
    <span class="k">while</span> <span class="n">string</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">productions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># Update current production</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">productions</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">yield</span> <span class="n">string</span>
</pre></div>

<p>We used the productions <code>11</code>, <code>01</code>, and <code>00</code> and the input <code>1</code>:</p>
<div class="highlight"><pre><span></span><span class="n">productions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">,</span> <span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="s1">&#39;00&#39;</span><span class="p">]</span>

<span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">cyclic_tag_system</span><span class="p">(</span><span class="n">productions</span><span class="p">,</span> <span class="n">string</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>

<p>Let&#39;s sketch an alternative implementation using the constructs we covered in
this post.</p>

<p>First, we can describe our production rules as lists of Boolean values. We
know how to represent Boolean values (<code>TRUE</code> and <code>FALSE</code>), and how to build
a list using <code>PAIR</code>. Our productions can be represented as:</p>
<div class="highlight"><pre><span></span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>   <span class="c1"># PAIR(TRUE)(PAIR(TRUE)(NULL))</span>
<span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>  <span class="c1"># PAIR(FALSE)(PAIR(TRUE)(NULL))</span>
<span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="c1"># PAIR(FALSE)(PAIR(FALSE)(NULL))</span>

<span class="n">productions</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="p">(</span><span class="n">p3</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
</pre></div>

<p>We can cycle through the list by processing the head, then appending it to
the tail of the list. Here are simpler implementations of our list processing
functions over Python tuples (though we know how to do these using only lambda
terms):</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">head</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">tail</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">xs</span> <span class="k">else</span> <span class="p">(</span><span class="n">head</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span>

<span class="c1"># If we want to cycle through our productions, we can do:</span>
<span class="c1"># productions = append(tail(productions), head(productions))</span>
</pre></div>

<p>We&#39;ll also need a function to concatenate two lists. We can easily build this
on top of <code>append()</code>:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">xs</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">ys</span> <span class="k">else</span> <span class="n">concat</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">head</span><span class="p">(</span><span class="n">ys</span><span class="p">)),</span> <span class="n">tail</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
</pre></div>

<p>While we still have <code>ys</code>, we append the head of <code>ys</code> to <code>xs</code>, then recurse
with the tail of <code>ys</code>.</p>

<p>We process our input string as follows: if it is empty, we are done. If not,
if the head is <code>1</code>, we concatenate our current production to the end of the
string, and recurse, cycling productions:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cyclic_tag_system</span><span class="p">(</span><span class="n">productions</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">input</span> <span class="k">else</span> \
        <span class="n">cyclic_tag_system</span><span class="p">(</span>
            <span class="c1"># Cycle productions</span>
            <span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">productions</span><span class="p">),</span> <span class="n">head</span><span class="p">(</span><span class="n">productions</span><span class="p">)),</span>
            <span class="c1"># If head is True, concatenate head production. Pop head input either way.</span>
            <span class="n">concat</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">head</span><span class="p">(</span><span class="n">productions</span><span class="p">))</span> <span class="k">if</span> <span class="n">head</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">else</span> <span class="n">tail</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>
</pre></div>

<p>Let&#39;s throw in a <code>print()</code> and run this on the same input as our original
example:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cyclic_tag_system</span><span class="p">(</span><span class="n">productions</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">input</span> <span class="k">else</span> \
        <span class="n">cyclic_tag_system</span><span class="p">(</span>
            <span class="c1"># Cycle productions</span>
            <span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="n">productions</span><span class="p">),</span> <span class="n">head</span><span class="p">(</span><span class="n">productions</span><span class="p">)),</span>
            <span class="c1"># If head is True, concatenate head production. Pop head input either way.</span>
            <span class="n">concat</span><span class="p">(</span><span class="n">tail</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">head</span><span class="p">(</span><span class="n">productions</span><span class="p">))</span> <span class="k">if</span> <span class="n">head</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">else</span> <span class="n">tail</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>

<span class="c1"># The input is equivalent to the string &#39;1&#39;</span>
<span class="n">cyclic_tag_system</span><span class="p">(</span><span class="n">productions</span><span class="p">,</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
</pre></div>

<p>This should produce output very similar to our original <code>cyclic_tag_system()</code>,
but using lists of Booleans instead of strings of <code>0</code>s and <code>1</code>s.</p>

<p>We emulated a cyclic tag system in lambda calculus - well, we didn&#39;t write all
the code as lambda terms, but everything is expressed as one-liner functions
that use only if-then-else expressions, lists (pair, head, tail), and recursion
(for which we have the \(Y\) combinator).</p>

<p>Lambda calculus has been extremely influential in computer science - it is the
root of functional programming. LISP, one of the earliest programming
languages, is heavily influenced by lambda calculus. Many ideas, like anonymous
functions, also known as <em>lambdas</em>, are now broadly available in most modern
programming languages (Python even uses the keyword <code>lambda</code> for these, as we
saw in this post).</p>

<h2>Summary</h2>

<p>In this post we covered lambda calculus:</p>

<ul>
<li>Lambda terms, including <em>variables</em>, <em>abstractions</em>, and <em>applications</em>.</li>
<li>Reductions: \(\alpha\)-equivalence, \(\beta\)-reduction, and \(\eta\)-reduction.</li>
<li>Church encoding for Boolean logic and arithmetic using lambda terms.</li>
<li>Combinators: the \(S\), \(K\), and \(I\) combinators which are sufficient to encode
all lambda terms, and the \(Y\) combinator which enables recursion.</li>
<li>Pairs and lists (defined using pairs), including an <code>append</code> operation.</li>
<li>Emulating a cyclic tag systems in lambda calculus.</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>See <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">this Wikipedia article</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>This <a href="https://kigawas.me/posts/y-combinator-in-python/">blog post</a> goes
  into the details if you are curious.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</article>
<nav>

<div id="prev"><span>« <a href="../../../2022/09/02/computability-part-7-machine-implementation-practicalities.html">Computability Part 7: Machine Implementation Practicalities</a></span></div>


<div id="next"><span><a href="../../../2022/12/01/computability-part-9-lisp.html">Computability Part 9: LISP</a> »</span></div>

</nav>
<footer><span>By <a href="https://vladris.com">Vlad Rișcuția</a> | <a href="../../../rss.xml">Subscribe</a> | <a href="../../../index.html">Index</a></span></footer>
</body>
</html>