<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Fibonacci &mdash; Blog</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="../../../static/theme.css" type="text/css">
<link rel="stylesheet" href="../../../static/tokyo.css" type="text/css">
<link rel="shortcut icon" href="../../../static/icon.ico" />
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header><span>February 11, 2018</span></header>
<article>
<h1>Fibonacci</h1>

<p>This blog post looks at a few algorithms to generate Fibonacci numbers.
For a much better treatment of these algorithms, I recommend <a href="https://www.goodreads.com/book/show/23498372-from-mathematics-to-generic-programming">From
Mathematics to Generic
Programming</a>.
The implementations are provided in poorly written Rust, as I&#39;m just
learning the language.</p>

<p>Learning Rust and going through <a href="https://doc.rust-lang.org/book/second-edition/">The Rust Programming
Language</a>, I got to <a href="https://doc.rust-lang.org/book/second-edition/ch03-05-control-flow.html#summary">the
end of chapter
3</a>,
where there are a few simple exercises. One of them is <em>Generate the nth
Fibonacci number</em>.</p>

<h2>The Fibonacci Sequence</h2>

<p>The Fibonacci sequence is defined as the sequence
\(F_n = F_{n-1} + F_{n-2}\) with the seed values \(F_0 = 0\) and \(F_1 = 1\).</p>

<p>The first few values of the sequence are 0, 1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, ....</p>

<h2>A Na√Øve Algorithm</h2>

<p>Directly translating the definition above into an algorithm to compute
the n-th Fibonacci number yields:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>This algorithm works for very small <code>n</code> values but it is extremely
inefficient as it has exponential time complexity and linear space
complexity (based on stack depth). Since
<code>fib(n - 1) = fib(n - 2) + fib(n - 3)</code>, a call like
<code>fib(n - 1) + fib(n - 2)</code> is equivalent to
<code>(fib(n - 2) + fib(n - 3)) + fib(n - 2)</code>, so the same elements of the
sequence end up being computed over and over again.</p>

<h2>Bottom-Up Approach</h2>

<p>A better way to generate the nth Fibonacci number is to build it
bottom-up, starting from \(F_0\) and \(F_1\):</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">b</span>
<span class="p">}</span>
</pre></div>

<p>Here we start with \(a = F_0, b = F_1\) and with each iteration of the
loop we advance from \(a = F_k, b = F_{k+1}\) to
\(a = F_{k+1}, b = F_{k+2}\) until <code>b</code> becomes \(F_n\).</p>

<p>Compared to the first algorithm, this is highly efficient, as it has
linear complexity and requires constant space. There are faster ways to
compute the nth Fibonacci number though.</p>

<h2>Matrix Form</h2>

<p>The Fibonacci sequence can also be described in matrix form as follows:</p>

<p>\[\begin{aligned}
\begin{bmatrix}
    F_{k+2} \\
    F_{k+1}
\end{bmatrix}=\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}*\begin{bmatrix}
    F_{k+1} \\
    F_k
\end{bmatrix}
\end{aligned}\]</p>

<p>Note that the next pair of numbers in the sequence, \(F_{k+3}, F_{k+2}\)
can be expressed as:</p>

<p>\[\begin{aligned}
\begin{bmatrix}
    F_{k+3} \\
    F_{k+2}
\end{bmatrix}=\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}*\begin{bmatrix}
    F_{k+2} \\
    F_{k+1}
\end{bmatrix}=\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}*\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}*\begin{bmatrix}
    F_{k+1} \\
    F_k
\end{bmatrix}
\end{aligned}\]</p>

<p>Thus we have the formula:</p>

<p>\[\begin{aligned}
\begin{bmatrix}
    F_n \\
    F_n - 1
\end{bmatrix}=\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; 0
\end{bmatrix}^{n-1}*\begin{bmatrix}
    F_1 \\
    F_0
\end{bmatrix}
\end{aligned}\]</p>

<p>Since \(F_0 = 0\) and \(F_1 = 1\), \(F_n\) is the element at index \((0, 0)\)
in:</p>

<p>\[\begin{aligned}
\begin{bmatrix}
1 &amp; 1 \\
1 &amp; 0
\end{bmatrix}^{n-1}
\end{aligned}\]</p>

<p>Assuming we have a function for exponentiating 2x2 matrices <code>exp2x2</code>, we
can implement an algorithm to compute the nth Fibonacci number like
this:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fib3</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span>
<span class="w">    </span><span class="p">];</span>

<span class="w">    </span><span class="n">exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>The complexity of this algorithm is given by the complexity of <code>exp2x2</code>.
A simple implementation of matrix exponentiation given a matrix
multiplication function <code>mul2x2</code> is:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">],</span>
<span class="w">        </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span>
<span class="w">    </span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul2x2</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">result</span>
<span class="p">}</span>
</pre></div>

<p>This function computes <code>a^n</code> by starting with the identity matrix and
multiplying it with a n times. The function for multiplying two 2x2
matrices is trivial:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
<span class="w">        </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>With <code>mul2x2</code> and <code>exp2x2</code>, our <code>fib3</code> algorithm has linear complexity,
which is determined by the number of times we call <code>mul2x2</code> in our
exponentiation function. There is a faster way to do exponentiation
though: observe that \(x^7 = x^4 * x^2 * x\). In general, any number <code>n</code>
and can be decomposed as a series of powers of two. So we can implement
a <code>fast_exp2x2</code> which works as follows:</p>
<div class="highlight"><pre><span></span>if n == 1, return a
if n is even, return fast_exp2x2(a * a, n / 2)
if n is odd, return fast_exp2x2(a * a, (n - 1) / 2) * a
</pre></div>

<p>We stop when our exponent is 1 and return <code>a</code>. If <code>n</code> is even, we square
the base and halve the exponent (for example \(x^8 = (x*x)^4\)). If <code>n</code> is
odd, we do the same but multiply by the base (for example
\(x^9 = (x*x)^4 *
x\)). This is a recursive algorithm which halves <code>n</code> at each step, so we
have logarithmic time and space complexity.</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fast_exp2x2</span><span class="p">(</span><span class="n">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">result</span>
<span class="p">}</span>
</pre></div>

<p>This is a very efficient way to compute the nth Fibonacci number. But
where does this fast exponentiation algorithm come from?</p>

<h2>Ancient Egyptian Multiplication</h2>

<p>The ancient Egyptian multiplication algorithm comes from the <a href="Rhind%20Mathematical%20Papyrus">Rhind
Papyrus</a> from around 1500 BC. The idea
is very similar to our fast exponentiation algorithm: we can implement a
fast multiplication algorithm by relying on addition and doubling (eg.
\(x * 7 = x * 4 + x * 2 + x\)). The steps or our <code>egyptian_mul</code> algorithm
are:</p>
<div class="highlight"><pre><span></span>if n == 1, return a
if n is even, return egyptian_mul(a + a, n / 2)
if n is odd, return egyptian_mul(a + a, (n - 1) / 2) + a
</pre></div>

<p>An implementation in Rust is:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">egyptian_mul</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">egyptian_mul</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">result</span>
<span class="p">}</span>
</pre></div>

<p>This multiplication algorithm relies only on addition, and multiplies
<code>a</code> by <code>n</code> in \(log(n)\) steps.</p>

<p><code>egyptian_mul</code> and <code>fast_exp2x2</code> algorithms have the same structure
since they are fundamentally the same: they provide an efficient way to
implement an operation defined as applying another operation n times.
Multiplication is, by definition, repeated addition. Similarly,
exponentiation is, by definition, repeated multiplication. We can
generalize these to an algorithm that given an initial value <code>a</code> of any
type <code>T</code>, an operation <code>op(T, T) -&gt; T</code>, and <code>n</code>, the number of times to
apply <code>op</code>, provides an efficient computation using doubling and
halving:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">op_n_times</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Copy</span><span class="p">,</span>
<span class="w">          </span><span class="n">Op</span><span class="p">:</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_n_times</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">result</span>
<span class="p">}</span>
</pre></div>

<p>We can express Egyptian multiplication (<code>egyptian_mul</code>) as addition
applied <code>n</code> times:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">egyptian_mul</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">std</span><span class="p">::</span><span class="n">ops</span><span class="p">::</span><span class="n">Add</span><span class="p">::</span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<p>Similarly, we can express fast matrix exponentiation (<code>fast_exp2x2</code>) as
matrix multiplication applied <code>n</code> times:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mul2x2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<h2>Industrial Strength Fibonacci</h2>

<p>I wanted to benchmark the two interesting implementations: <code>fib2</code> and
<code>fib4</code>. The first exponential complexity implementation is highly
inefficient and even for small values of <code>N</code> (eg. <code>N = 50</code>) it takes a
long time to complete. <code>fib3</code> has linear complexity like <code>fib2</code>, but
while <code>fib2</code> just performs additions and assignments on each iteration,
<code>fib3</code> performs matrix multiplication, which is more expensive. So
<code>fib2</code> and <code>fib4</code> are more interesting to look at.</p>

<p>Turns out that the Fibonacci sequence grows quite fast, the 100th
Fibonacci number is <code>354224848179261915075</code>, which does not fit in an
<code>i32</code>. So let&#39;s update the implementations to use <code>num::BigUint</code>, an
arbitrary precision number. First is <code>fib2</code>:</p>
<div class="highlight"><pre><span></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>

<span class="k">use</span><span class="w"> </span><span class="n">num</span><span class="p">::</span><span class="n">bigint</span><span class="p">::{</span><span class="n">BigUint</span><span class="p">,</span><span class="w"> </span><span class="n">ToBigUint</span><span class="p">};</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">fib2</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">BigUint</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">b</span>
<span class="p">}</span>
</pre></div>

<p>For <code>fib4</code>, we need to update <code>mul2x2</code> to work with <code>BigUint</code> array
references, so we don&#39;t copy <code>BigUint</code> arrays:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">mul2x2</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">])</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<p>We also need to update our <code>op_n_times</code> so the operation now takes <code>&amp;T</code>
instead of <code>T</code>. Note this version still works with <code>i32</code> arrays and
numbers, but now the operation is expected to take two references
instead of two values. On the other hand we no longer require that <code>T</code>
has the <code>Copy</code> trait:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">op_n_times</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">op</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span>
<span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">Op</span><span class="p">:</span><span class="w"> </span><span class="nb">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_n_times</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">result</span>
<span class="p">}</span>
</pre></div>

<p>Then we can update our <code>fib4</code> implementation to use <code>BigUint</code>:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span><span class="w"> </span><span class="nf">fast_exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">[[</span><span class="n">BigUint</span><span class="p">;</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">op_n_times</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mul2x2</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">fib4</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">BigUint</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">        </span><span class="p">[</span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()],</span>
<span class="w">        </span><span class="p">[</span><span class="mf">1.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">(),</span><span class="w"> </span><span class="mf">0.</span><span class="n">to_biguint</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()],</span>
<span class="w">    </span><span class="p">];</span>

<span class="w">    </span><span class="n">fast_exp2x2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">clone</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>

<p>These two implementations work with arbitrarily large numbers, for
example <code>fib4(10_000)</code> is:</p>

<blockquote style="word-wrap:break-word">
33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875
</blockquote>

<p>We can benchmark these implementations using Rust&#39;s built-in
benchmarking:</p>
<div class="highlight"><pre><span></span><span class="p">#</span><span class="cp">#[bench]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">fib4_bench</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">fib4</span><span class="p">(</span><span class="n">N</span><span class="p">));</span>
<span class="p">}</span>

<span class="p">#</span><span class="cp">#[bench]</span>
<span class="k">fn</span><span class="w"> </span><span class="nf">fib2_bench</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Bencher</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="n">fib2</span><span class="p">(</span><span class="n">N</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>On my Surface Book, for <code>N = 100</code>, we have:</p>
<div class="highlight"><pre><span></span>test tests::fib2_bench ... bench:       7,805 ns/iter (+/- 3,042)
test tests::fib4_bench ... bench:       6,140 ns/iter (+/- 356)
</pre></div>

<p>For <code>N = 1_000</code>:</p>
<div class="highlight"><pre><span></span>test tests::fib2_bench ... bench:      89,131 ns/iter (+/- 28,346)
test tests::fib4_bench ... bench:      16,307 ns/iter (+/- 2,087)
</pre></div>

<p>For <code>N = 10_000</code>:</p>
<div class="highlight"><pre><span></span>test tests::fib2_bench ... bench:   2,121,140 ns/iter (+/- 132,448)
test tests::fib4_bench ... bench:     184,625 ns/iter (+/- 12,184)
</pre></div>

<p>For <code>N = 100_000</code>:</p>
<div class="highlight"><pre><span></span>test tests::fib2_bench ... bench: 128,769,418 ns/iter (+/- 5,198,789)
test tests::fib4_bench ... bench:   7,176,026 ns/iter (+/- 364,400)
</pre></div>

<p>While <code>fib2</code> and <code>fib4</code> start with about the same performance at
<code>N = 100</code>, for <code>N = 100_000</code>, <code>fib4</code> is significantly faster. The
benchmark results don&#39;t seem to reflect the algorithmic complexity of
<code>fib2</code> (linear) and <code>fib4</code> (logarithmic), I suspect because of the
introduction of <code>BigUint</code> and operations on large numbers. Still, the
algorithm relying on fast exponentiation performs many times faster on
large Ns.</p>

<h2>Summary</h2>

<p>This blog post covered:</p>

<ul>
<li>Algorithms to generate Fibonacci numbers: na√Øve recursive
(exponential), bottom-up (linear), matrix exponentiation (linear or
logarithmic, depending on the matrix exponentiation algorithm).</li>
<li>Ancient Egyptian multiplication and fast matrix exponentiation are
the same algorithm applied to different operations.</li>
<li>A generic algorithm of efficiently applying an operation n times.</li>
<li>Algorithms to generate Fibonacci numbers implemented with <code>BigUint</code>
for arbitrary precision numbers.</li>
<li>Benchmarking the <code>fib2</code> and <code>fib4</code> algorithms shows <code>fib4</code> to be
much better as <code>N</code> increases.</li>
</ul>

<p>My humble conclusion is that generating Fibonacci numbers is more than
an introductory exercise.</p>

</article>
<nav>

<div id="prev"><span>¬´ <a href="../../../2018/01/27/notes-on-oop.html">Notes on OOP</a></span></div>


<div id="next"><span><a href="../../../2018/04/15/kami-2.html">Kami 2</a> ¬ª</span></div>

</nav>
<footer><span>By <a href="https://vladris.com">Vlad Ri»ôcu»õia</a> | <a href="../../../rss.xml">Subscribe</a> | <a href="../../../index.html">Index</a></span></footer>
<script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
</script>
</body>
</html>