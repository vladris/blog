<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>IoC Containers &mdash; Blog</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="../../../static/light.css" type="text/css">
<link rel="stylesheet" href="../../../static/pygments.css" type="text/css">
<link rel="shortcut icon" href="../../../static/icon.ico" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<header><span>June 23, 2018</span></header>
<article>
<h1>IoC Containers</h1>

<p>In this post I will go over the basics of IoC containers and walk
through a very simple C# implementation.</p>

<h2>Motivation</h2>

<p>An inversion of control container is a component that encapsulates
dependency injection and lifetime management of other components<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.
Assume we have some well componentized code where classes work against
interfaces:</p>
<div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">IFoo</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">void</span><span class="w"> </span><span class="nf">DoFoo</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Foo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IFoo</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">DoFoo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bar</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Coded against IFoo interface, so decoupled from</span>
<span class="w">    </span><span class="c1">// concrete Foo implementation</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Bar</span><span class="p">(</span><span class="n">IFoo</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">foo</span><span class="p">.</span><span class="n">DoFoo</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>In order to create an instance of <code>Bar</code>, we need to pass it some <code>IFoo</code>
object. We could do it by <code>new</code>-ing up a <code>Foo</code> object at the call site
of <code>Bar</code>&#39;s constructor:</p>
<div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Bar</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">());</span><span class="w"></span>
</pre></div>

<p>This doesn&#39;t scale very well though. Most classes require more than one
dependency, so we can&#39;t realistically litter the code with:</p>
<div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">D</span><span class="p">()),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">E</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">D</span><span class="p">()));</span><span class="w"></span>
</pre></div>

<p>Factory functions address part of the problem. We can have, for example:</p>
<div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="n">IA</span><span class="w"> </span><span class="nf">MakeIA</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span><span class="w"> </span><span class="n">MakeIE</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Another advantage of using factory functions instead of directly calling
constructors is that a factory can encapsulate lifetime of objects.
Changing from a new instance on every call to a singleton can be
encapsulated in the factory so callers of <code>MakeIA</code> don&#39;t need to
change.</p>

<p>We would then call <code>MakeIA</code> whenever we needed an <code>IA</code> instance. But
where do these factories belong? They do not belong with the concrete
types they are implementing, because having a static <code>MakeIA</code> on class
<code>A</code> would still require callers to reference <code>A</code> (as in <code>A.MakeIA()</code>).
Since these factories become the only places in the system where
knowledge of which type resolves to which interface, it makes sense to
keep them together:</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Factories</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">IA</span><span class="w"> </span><span class="nf">MakeIA</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">A</span><span class="p">(</span><span class="n">MakeIB</span><span class="p">(),</span><span class="w"> </span><span class="n">MakeIE</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">IB</span><span class="w"> </span><span class="nf">MakeIB</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">B</span><span class="p">(</span><span class="n">MakeIC</span><span class="p">(),</span><span class="w"> </span><span class="n">MakeID</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">IC</span><span class="w"> </span><span class="nf">MakeIC</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">C</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="nf">MakeID</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">D</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">IE</span><span class="w"> </span><span class="nf">MakeIE</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">E</span><span class="p">(</span><span class="n">MakeID</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>This works pretty well: changing which concrete type binds to an
interface becomes a changed scoped to one of the factories. But
maintaining this by hand can become tedious. The good news is it can be
automated, which is what an IoC container does.</p>

<h2>A Basic IoC Container</h2>

<p>A very basic container would be able to bind a concrete implementation
against an interface and return an instance of the concrete
implementation when asked for an interface:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="cm">/* ... */</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>The simplest possible thing to pass to <code>Register</code> is a factory function,
in which case our container would have to maintain a mapping from type
to factory:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="w"> </span><span class="n">factory</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">class</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">factory</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>This is how it can be used:</p>
<div class="highlight"><pre><span></span><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(),</span><span class="w"> </span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;()));</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(),</span><span class="w"> </span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="p">());</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">D</span><span class="p">());</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">E</span><span class="p">(</span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;()));</span><span class="w"></span>

<span class="c1">// ...</span>

<span class="kt">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span><span class="w"></span>
</pre></div>

<p>This is fine, but still requires a lot of hand-maintenance. One of the
main features of a container is the ability to use reflection and
resolve some of these dependencies automatically. Given a type, we can
find its first public constructor by calling <code>GetConstructor</code> on it:</p>
<div class="highlight"><pre><span></span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">param</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">).</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">().</span><span class="n">GetParameters</span><span class="p">())</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">param</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>So given a type, we should be able to generate a factory function for
it. A simple way of doing it is by calling <code>Invoke</code> on the retrieved
constructor and attempting to retrieve all its arguments from the
container:</p>
<div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">constructor</span><span class="p">.</span><span class="n">Invoke</span><span class="p">(</span><span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">param</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]()</span><span class="w"></span>
<span class="w">        </span><span class="p">).</span><span class="n">ToArray</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Now registering the interfaces becomes a lot easier:</p>
<div class="highlight"><pre><span></span><span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">A</span><span class="p">));</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IB</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">B</span><span class="p">));</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IC</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">C</span><span class="p">));</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">ID</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">D</span><span class="p">));</span><span class="w"></span>
<span class="n">Container</span><span class="p">.</span><span class="n">Register</span><span class="p">&lt;</span><span class="n">IE</span><span class="p">&gt;(</span><span class="k">typeof</span><span class="p">(</span><span class="n">E</span><span class="p">));</span><span class="w"></span>

<span class="c1">// ...</span>

<span class="kt">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IA</span><span class="p">&gt;();</span><span class="w"></span>
</pre></div>

<p>It&#39;s usually a good idea to support registration by both type and
factory function, for cases where the construction is more involved or
the types of the constructor arguments, for various reasons, are not
registered with the container.</p>

<h3>Efficient Construction</h3>

<p>Calling <code>Invoke</code> on a <code>ConstructorInfo</code> is notoriously slow<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>. There
are several strategies to make this invocation faster. One of them is by
using <code>System.Linq.Expressions</code>, which are a set of types that help
declare and compile lambdas at runtime:</p>
<div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span><span class="w"> </span><span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">param</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">resolve</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span><span class="w"> </span><span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span><span class="w"></span>
<span class="w">                    </span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">))).</span><span class="n">Compile</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>The above implementation compiles a lambda which is equivalent to the
<code>Invoke</code> logic. There are several other techniques to dynamically
generate functions, including <code>Reflection.Emit</code> and
<code>System.Runtime.CompilerServices</code>. Another decision point is whether
resolution is done lazily or not. The above implementation is lazy,
resolving each constructor parameter does not require an entry for it in
the container when this particular lambda is compiled. The relevant line
is:</p>
<div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">resolve</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span><span class="w"></span>
</pre></div>

<p>If we were to replace this with:</p>
<div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">resolve</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">];</span><span class="w"></span>
</pre></div>

<p>it would fail to compile the lambda when registering <code>A</code> unless all
other dependencies are already in the container. This approach is
flexible, in that type bindings can be resolved at runtime, but can
incur a bit more overhead. An alternative would be to register all types
with the container first, then generate the factories in a separate
step. In that case, for each type, we could map out exactly what calls
need to be made to set it up based on information already available to
the container. Such an implementation gets more complex, so I won&#39;t go
into the details, but worth noting that it is possible.</p>

<h2>Lifetimes</h2>

<p>Containers also encapsulate lifetime management. The most basic
non-instance lifetime is singleton, which means a unique instance during
the lifetime of the app. Let&#39;s extend our container to also support
resolving singletons. First we need a way to wrap a factory into a
function that only calls it once, then caches the result:</p>
<div class="highlight"><pre><span></span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">factory</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>This relies on <code>Lazy</code> to ensure uniqueness. Now we can enable singleton
registrations for factories and types:</p>
<div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>This effectively decorated the registered factory with the singleton
logic. There are various other lifetimes an object could require, for
example: threaded (where instances are cached per thread, so the same
instance is always returned on the same thread but not across threads),
scoped (where there is an API to mark beginning and end of a scope
within which the same instance is always returned, but another one gets
created in another scope) etc.</p>

<h2>A Note on Loading</h2>

<p>One interesting observation made while profiling a .NET application is
that a container usually forces the loading of all referenced assembly.
The .NET runtime defers assembly loading until a method is called which
references a type in a not-yet-loaded assembly. This forces assembly
loading as the runtime needs the metadata of the type. When using an IoC
container, all types are usually registered as soon as the application
boots, in which case all assemblies get pulled in during registration
time (as opposed to on-demand at a later time).</p>

<h2>Resources</h2>

<p>The complete source code for the container in this blog post is:</p>
<div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Container</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;&gt;();</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="w"> </span><span class="n">factory</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">class</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">factory</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Register</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">GetConstructors</span><span class="p">().</span><span class="n">First</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;)</span><span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="n">Expression</span><span class="p">.</span><span class="n">New</span><span class="p">(</span><span class="n">constructor</span><span class="p">,</span><span class="w"> </span><span class="n">constructor</span><span class="p">.</span><span class="n">GetParameters</span><span class="p">().</span><span class="n">Select</span><span class="p">(</span><span class="w"></span>
<span class="w">                </span><span class="n">param</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"></span>
<span class="w">                </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">resolve</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">]();</span><span class="w"></span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="n">Expression</span><span class="p">.</span><span class="n">Convert</span><span class="p">(</span><span class="w"></span>
<span class="w">                        </span><span class="n">Expression</span><span class="p">.</span><span class="n">Call</span><span class="p">(</span><span class="n">Expression</span><span class="p">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">resolve</span><span class="p">.</span><span class="n">Target</span><span class="p">),</span><span class="w"> </span><span class="n">resolve</span><span class="p">.</span><span class="n">Method</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="n">param</span><span class="p">.</span><span class="n">ParameterType</span><span class="p">);</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">))).</span><span class="n">Compile</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">MarkSingleton</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">_registeredTypes</span><span class="p">[</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">)]();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">SingletonDecorator</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;</span><span class="w"> </span><span class="n">factory</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Lazy</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">&gt;(</span><span class="n">factory</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>I also recently open-sourced a minimal container
<a href="https://github.com/microsoft/minioc">here</a>. That implementation
includes support for scoped lifetimes, but otherwise it is still very
minimal. It was used in a couple of small projects where constraints
were around size/dependent assemblies rather than feature richness.</p>

<p>For a popular open source container with many more features, check out
<a href="https://autofac.org/">AutoFac</a>.</p>

<h2>Summary</h2>

<p>In this post we went over a few IoC container basics:</p>

<ul>
<li>Motivation for containers.</li>
<li>A primitive container supporting factory registration.</li>
<li>Using reflection to support type registration.</li>
<li>Approaches to implementing constructor calls: <code>Inove</code>,
<code>Linq.Expressions</code>, others. Lazy resolution vs. generating
constructor calls in a separate step.</li>
<li>Lifetime management and a singleton implementation.</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>For a much more detailed treatment, see Martin Fowler&#39;s
<a href="https://www.martinfowler.com/articles/injection.html">article</a>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>An interesting benchmark on <a href="https://stackoverflow.com/questions/35805609/performance-of-expression-compile-vs-lambda-direct-vs-virtual-calls">Stack
Overflow</a>&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</article>
<nav>

<div id="prev"><span>« <a href="../../../2018/04/15/kami-2.html">Kami 2</a></span></div>


<div id="next"><span><a href="../../../2018/07/16/implementing-a-variant-type-in-csharp.html">Implementing a Variant Type in C#</a> »</span></div>

</nav>
<footer><span>By Vlad Rișcuția | <a href="../../../rss.xml">Subscribe</a> | <a href="../../../index.html">Index</a></span></footer>
</body>
</html>