<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Unit Testing 101 &mdash; Blog</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="../../../static/style.css" type="text/css">
<link rel="stylesheet" href="../../../static/pygments.css" type="text/css">
<link rel="shortcut icon" href="../../../static/icon.ico" />
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<header><span>November 18, 2019</span></header>
<article>
<h1>Unit Testing 101</h1>

<p>I wrote a while back about <a href="https://vladris.com/blog/2017/11/09/notes-on-unit-testing.html">unit
testing</a>
from a philosophical perspective. This post is going to be more
pragmatic. My team is currently doing some MQ work which includes
improving our unit test story across the codebase. I put together a
short unit tests 101 presentation outlining some key principles:</p>

<ul>
<li>Run with each build.</li>
<li>100% reliability.</li>
<li>Test the public interface.</li>
</ul>

<h2>Run with Each Build</h2>

<p>Unit tests that don&#39;t run aren&#39;t very useful. I&#39;ve seen projects
before where a unit test project does exist but the tests only run if
manually executed.</p>

<p>The problem with this approach is that tests can stay not running for
days/weeks/months, and when they finally run, a bunch of them fail. Good
luck finding the change that introduced the regression. And wait, were
we running with that behavior all this time?</p>

<p>The biggest bang for the buck is making sure unit tests run as part of a
continuous integration build and pull requests get auto-rejected if a
unit test fails.</p>

<h2>100% Reliability</h2>

<p>Once unit tests run with each build, the next most important thing to
look into is ensuring they pass consistently. Flaky unit tests are bad
because there&#39;s no easy way to tell if a test run failed because of a
regression or a flaky test. Worst, if flaky tests are the standard,
engineers start ignoring the results. Hard to distill the signal from
the noise in those situations. Merge policies become more lax - after
all, we can&#39;t demand 100% green if some unit tests randomly fail.</p>

<p>But stepping back, when are tests flaky? When they perform IO. Hitting
the network, connecting to a database, reading a file, these are all
cases in which a transient issue outside of our control can cause a test
to fail. That&#39;s why unit tests shouldn&#39;t perform IO, rather they
should work against mocks.</p>

<p>Let&#39;s take, as an example, a method which performs a GET request and
logs to the console whether the request was successful:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Get</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HttpClient</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;https://www.example.com&quot;</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>In its current form, the method isn&#39;t really testable. Writing code
without thinking about testability yields such methods. We can refactor
this to be more testable. First, let&#39;s put all IO behind interfaces:</p>
<div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">IHttpClient</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span><span class="w"> </span><span class="n">GetAsync</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">url</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">interface</span><span class="w"> </span><span class="n">IOutput</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">void</span><span class="w"> </span><span class="nf">WriteLine</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="k">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>We can update our <code>Example</code> to use these interfaces instead of directly
working with <code>HttpClient</code> and <code>Console</code>:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">IHttpClient</span><span class="w"> </span><span class="n">client</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">IOutput</span><span class="w"> </span><span class="n">output</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="nf">Example</span><span class="p">(</span><span class="n">IHttpClient</span><span class="w"> </span><span class="n">client</span><span class="p">,</span><span class="w"> </span><span class="n">IOutput</span><span class="w"> </span><span class="n">output</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">client</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">client</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="n">output</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">output</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Get</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="w"></span>
<span class="w">            </span><span class="s">&quot;https://www.example.com&quot;</span><span class="p">).</span><span class="n">Result</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">IsSuccessStatusCode</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>We add adapters between the interfaces and the actual implementations:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">HttpClientWrapper</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IHttpClient</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="n">HttpClient</span><span class="w"> </span><span class="n">client</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HttpClient</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">Task</span><span class="p">&lt;</span><span class="n">HttpResponseMessage</span><span class="p">&gt;</span><span class="w"> </span><span class="n">GetAsync</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">url</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="n">url</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">ConsoleOutput</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IOutput</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">WriteLine</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="k">value</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="k">value</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>With these adapters, in our production code we can put together an
instance of <code>Example</code> that works just like the original, but which is
componentized enough that we can actually test it:</p>
<div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">HttpClientWrapper</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="nf">ConsoleOutput</span><span class="p">());</span><span class="w"></span>
<span class="n">example</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>In our test code, we can use a framework like Moq<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> to set up mocks
and verify that the expected calls happen:</p>
<div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">mockClient</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Mock</span><span class="p">&lt;</span><span class="n">IHttpClient</span><span class="p">&gt;();</span><span class="w"></span>
<span class="n">mockClient</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">client</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">client</span><span class="p">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="s">&quot;https://www.example.com&quot;</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">Returns</span><span class="p">(</span><span class="n">Task</span><span class="p">.</span><span class="n">FromResult</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="k">new</span><span class="w"> </span><span class="n">HttpResponseMessage</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">StatusCode</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">OK</span><span class="w"></span>
<span class="w">        </span><span class="p">}));</span><span class="w"></span>

<span class="kt">var</span><span class="w"> </span><span class="n">mockOutput</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Mock</span><span class="p">&lt;</span><span class="n">IOutput</span><span class="p">&gt;();</span><span class="w"></span>
<span class="n">mockOutput</span><span class="p">.</span><span class="n">Setup</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">output</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="n">It</span><span class="p">.</span><span class="n">Is</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;(</span><span class="k">value</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="p">==</span><span class="w"> </span><span class="k">true</span><span class="p">)));</span><span class="w"></span>

<span class="kt">var</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">mockClient</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">mockOutput</span><span class="p">.</span><span class="n">Object</span><span class="p">);</span><span class="w"></span>
<span class="n">example</span><span class="p">.</span><span class="n">Get</span><span class="p">();</span><span class="w"></span>

<span class="n">mockOutput</span><span class="p">.</span><span class="n">VerifyAll</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>The above code sets up an <code>IHttpClient</code> mock implementation which so
that when <code>GetAsync()</code> is called with the argument
<code>https://www.example.com</code> it returns a <code>Task&lt;HttpResponseMessage&gt;</code> with
a <code>StatusCode</code> of <code>HttpStatusCode.OK</code>. The code also sets up an
<code>IOutput</code> mock which expects a <code>WriteLine()</code> call with a <code>true</code>
argument.</p>

<p>We can initialize an instance of <code>Example</code> with these mocks, call
<code>Get()</code>, then verify <code>mockOutput</code> was used as expected.</p>

<h3>Design for Testability</h3>

<p>The general steps for making code testable:</p>

<ul>
<li>Extract interface (if one doesn&#39;t exist already).</li>
<li>Create adapters if concrete implementation doesn&#39;t implement an
interface.</li>
<li>Initialize class with real implementations in production.</li>
<li>Initialize class with mocks in tests.</li>
<li>Setup mocks to behave as required by each test.</li>
<li>Verify mocks.</li>
</ul>

<p>I will not talk about dependency injection in this post, but once all
components of the system expect several interfaces to run, it is worth
thinking about leveraging a DI framework to handle putting things
together.</p>

<p>With this approach, we can make any component testable except the
adapters. By their nature, our adapters perform IO. We can&#39;t reliably
test <code>HttpClientWrapper</code>. But such adapters shouldn&#39;t contain any
application logic, they should be extremely thin, simply forwarding
calls to the real implementation. It&#39;s perfectly fine to not test such
trivial code.</p>

<h3>Seams</h3>

<p>Depending on the language, we can have several other ways to inject
mocks. In C++, for example, we can do it at compile-time, at link-time,
or at run-time.</p>

<p>At compile-time, we can use a template parameter as the <q>interface</q>,
have the production version of the code instantiate it with one concrete
implementation and have the tests instantiate it with a mock:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TImpl</span><span class="o">&gt;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">TImpl</span><span class="w"> </span><span class="n">impl</span><span class="p">;</span><span class="w"></span>

<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Do</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">impl</span><span class="p">.</span><span class="n">Do</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">ConcreteImpl</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Do</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Concrete implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockImpl</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Do</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Mock implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// ...</span>

<span class="n">Example</span><span class="o">&lt;</span><span class="n">ConcreteImpl</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ex</span><span class="p">;</span><span class="w"></span>
</pre></div>

<p>At link-time, we can link against the concrete implementations in
production and against mock implementations in tests:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">Impl</span><span class="w"> </span><span class="n">impl</span><span class="p">;</span><span class="w"></span>

<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Do</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">impl</span><span class="p">.</span><span class="n">Do</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// In concrete implementation file:</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Impl</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Do</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Concrete implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// In mock implementation file:</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Impl</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Do</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Mock implementation</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>

<p>At run-time, we can do something similar to our C# example above. There
are pros and cons with each approach. The run-time approach is what most
languages do, so easy to understand, though it adds more overhead. The
link-time approach is lean, but could end up being confusing: we have to
check makefiles to understand which code ends up in the binary and which
code doesn&#39;t. The compile-time approach makes the code uglier, and
requires making implementation public.</p>

<h2>Test The Public Interface</h2>

<p>This one I did mention in my previous blog post to. The key point here
is that, while test frameworks usually provide various unnatural ways to
access an object&#39;s internals, tests should focus on the public members.</p>

<p>The public members define the <q>contract</q> that a class provides. Tests
should ensure the contract is respected and not worry about the
implementation. With this approach, the implementation can easily be
refactored and we know things still work as expected as long as all
tests pass. On the other hand, if we have tests that cover various
implementation details, they might break if we move things around, even
though the class still behaves correctly. In general, having to update
tests whenever we make tweaks to the implementation is not ideal.</p>

<p>The other way to look at it is that if we have some code deep in the
implementation that can&#39;t be reached through the public members, then
it is likely dead code.</p>

<h2>Summary</h2>

<ul>
<li>Unit tests should run as part of continuous integration, otherwise
they aren&#39;t really useful.</li>
<li>Unit tests have to be 100% reliable. We achieve this by isolating IO
and mocking it in tests.</li>
<li>Testability recipe:

<ul>
<li>Code against interfaces, declare interfaces if none are
available</li>
<li>Use thin adapters to make any concrete implementation compatible
with any interface</li>
<li>Use concrete implementations in production and mocks in tests</li>
</ul></li>
<li>In some languages there are multiple seams where we can inject
mocks. In C++ we can do it at compile-time, at link-time, and at
run-time. Each has its pros and cons.</li>
<li>Test the public interface not the implementation.</li>
</ul>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Moq is my favorite C# mocking library:
<a href="https://github.com/moq/moq4">https://github.com/moq/moq4</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</article>
<nav>
<div id="prev"><span>« <a href=../../.././2019/10/16/programming-with-types-rtm.html>Programming with Types RTM</a></span></div>
<div id="next"><span><a href=../../.././2019/12/08/notes-on-data-engineering.html>Notes on Data Engineering</a> »</span></div>
</nav>
<footer><span>By Vlad Rișcuția | <a href="../../../index.html">Index</a></span></footer>
</body>
</html>