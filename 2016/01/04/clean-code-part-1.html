<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Clean Code - Part 1 &mdash; Blog</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="../../../static/style.css" type="text/css">
<link rel="stylesheet" href="../../../static/pygments.css" type="text/css">
<link rel="shortcut icon" href="../../../static/icon.ico" />
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<header><span>January 04, 2016</span></header>
<article>
<h1>Clean Code - Part 1</h1>

<p>These posts are based on a Clean Code talk I did for my team a few
months ago, which, in turn, was inspired by the advice I gave to some of
our summer interns as four rules of thumb for writing cleaner code:</p>

<ul>
<li>Write less code</li>
<li>Write simple code</li>
<li>Write stateless code</li>
<li>Write readable code</li>
</ul>

<p>I will cover the first two points in this post and the remaining two in
Part 2. I&#39;m talking about C++ and C# throughout, but most of this
should be applicable to any object-oriented or multi-paradigm language.</p>

<h2>Write Less Code</h2>

<blockquote>
<p>The number of defects found in open source projects was 0.45
defects/1,000 lines of code, while the industry&#39;s average is around 1
defect per 1,000 lines of code for companies not using automated
testing such as static analysis.</p>

<p><em>Source:</em>
<a href="http://www.infoq.com/news/2012/03/Defects-Open-Source-Commercial">InfoQ</a></p>
</blockquote>

<p>A great way to have fewer bugs is to have fewer lines of code! What I
mean by this is that churning out many lines of code is by no means a
measure of productivity yet, unfortunately, most developers still feel
great when, at the end of the day, we wrote <em>insert high number</em> LoC.</p>

<h3>How to write less code?</h3>

<p>Two points to keep in mind: first, don&#39;t reinvent the wheel - don&#39;t
write code if there is an existing library, internal to your company or
open-source, that already does what needs to be done. Case in point, we
refactored some code for a project (C#), extracted some interfaces,
componentized things, and wrote a bunch of unit tests. All of this was
great, except we ended up with a bunch of handcrafted stub classes: for</p>
<div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">IMyComponent</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">void</span><span class="w"> </span><span class="nf">Foo</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">Bar</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">void</span><span class="w"> </span><span class="nf">Baz</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>we had</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyComponentStub</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IMyComponent</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Foo</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Bar</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Baz</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="kt">var</span><span class="w"> </span><span class="n">myComponentStub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyComponentStub</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>and so on. Implementing these stubs was tedious, needless work - we
integrated <a href="https://github.com/Moq/moq4">Moq</a> , a mocking library, and
the above code turned into:</p>
<div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="nn">Moq</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="kt">var</span><span class="w"> </span><span class="n">myComponentStub</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">Mock</span><span class="p">.</span><span class="n">Of</span><span class="p">&lt;</span><span class="n">IMyComponent</span><span class="p">&gt;();</span><span class="w"></span>
</pre></div>

<p>Moq uses reflection to stub out interfaces at run-time, so simply
adopting the library helped us get rid of a lot of code.</p>

<p>The second way to write less code is to know the standard library of
your language of choice. Many times, a block of code can be replaced
with a simple library call. For C++, pay particular attention to the STL
<code>&lt;algorithm&gt;</code> header and for C#, <code>System.Linq</code>. Both contain many of
useful algorithms which can replace a lot of code.</p>

<p>I also recommend watching Sean Parent&#39;s <a href="https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning">C++
Seasoning</a>
talk, one of the best tech talks I&#39;ve seen. The example he gives in the
talk (from the Chrome codebase) shows how a couple of lines of STL code
can be used instead of a whole convoluted function:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">PanelBar::RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span><span class="w"> </span><span class="n">fixed_panel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// First, find the index of the fixed panel.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Next, check if the panel has moved to the other side of another panel.</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">center_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Panel</span><span class="o">*</span><span class="w"> </span><span class="n">panel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">center_x</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"></span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panel</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">fixed_panel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// If it has, then we reorder the panels.</span>
<span class="w">        </span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Find the total width of the panels to the left of the fixed panel.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">total_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Panel</span><span class="o">*</span><span class="w"> </span><span class="n">panel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panel</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">fixed_panel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">total_width</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="n">CHECK_NE</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Move panels over to the right of the fixed panel until all of the ones</span>
<span class="w">  </span><span class="c1">// on the left will fit.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">avail_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">total_width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">avail_width</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">new_fixed_index</span><span class="o">--</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">CHECK_GE</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">total_width</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Reorder the fixed panel if its index changed.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_fixed_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Now find the width of the panels to the right, and move them to the</span>
<span class="w">  </span><span class="c1">// left as needed.</span>
<span class="w">  </span><span class="n">total_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">          </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">total_width</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">avail_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">fixed_panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">total_width</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">avail_width</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">new_fixed_index</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">CHECK_LT</span><span class="p">(</span><span class="n">new_fixed_index</span><span class="p">,</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">total_width</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">new_fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Do the reordering again.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">new_fixed_index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Finally, push panels to the left and the right so they don&#39;t overlap.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">boundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">       </span><span class="c1">// Start at the panel to the left of &#39;new_fixed_index&#39;.</span>
<span class="w">       </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="p">);</span><span class="w"></span>
<span class="w">       </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Panel</span><span class="o">*</span><span class="w"> </span><span class="n">panel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">boundary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span><span class="w"> </span><span class="n">kAnimMs</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">boundary</span><span class="p">,</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">),</span><span class="w"> </span><span class="n">kAnimMs</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">boundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">boundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">[</span><span class="n">fixed_index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Panels</span><span class="o">::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">new_fixed_index</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">       </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">it</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Panel</span><span class="o">*</span><span class="w"> </span><span class="n">panel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_panel_left</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">boundary</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">boundary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span><span class="w"> </span><span class="n">kAnimMs</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">Move</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">boundary</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">panel_width</span><span class="p">(),</span><span class="w"></span>
<span class="w">                  </span><span class="n">wm_</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">),</span><span class="w"></span>
<span class="w">                  </span><span class="n">kAnimMs</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">boundary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">panel</span><span class="o">-&gt;</span><span class="n">cur_right</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kBarPadding</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>becomes:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">PanelBar::RepositionExpandedPanels</span><span class="p">(</span><span class="n">Panel</span><span class="o">*</span><span class="w"> </span><span class="n">fixed_panel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK</span><span class="p">(</span><span class="n">fixed_panel</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// First, find the index of the fixed panel.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fixed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetPanelIndex</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">fixed_panel</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">CHECK_LT</span><span class="p">(</span><span class="n">fixed_index</span><span class="p">,</span><span class="w"> </span><span class="n">expanded_panels_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"></span>

<span class="w">  </span><span class="c1">// Next, check if the panel has moved to the left side of another panel.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fixed_index</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lower_bound</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">expanded_panels_</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">center_x</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">Panel</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">e</span><span class="o">-&gt;</span><span class="n">cur_panel_center</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="w">  </span><span class="c1">// If it has, then we reorder the panels.</span>
<span class="w">  </span><span class="n">rotate</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Code snippets borrowed from Sean Parent&#39;s slides, I highly recommend
watching the whole talk.</p>

<p>The key takeaway here is that there could be a standard library
implementation or an external module that can greatly simplify your work
and it&#39;s a good practice to always ask yourself <em><q>do I really need to
write this?</q></em></p>

<h2>Write Simple Code</h2>

<p>First, a few notes on cyclomatic complexity from Wikipedia:</p>

<blockquote>
<p>Cyclomatic complexity is a software metric (measurement), used to
indicate the complexity of a program. It is a quantitative measure of
the number of linearly independent paths through a program&#39;s source
code.</p>

<p>The complexity M is then defined as</p>

<p><em>M = E − N + 2P</em></p>

<p>where</p>

<p><em>E = the number of edges of the graph, N = the number of nodes of
the graph, P = the number of connected components.</em></p>

<p><img src="cyclomatic_complexity.svg" alt="image"></p>

<p>A control flow graph of a simple program. The program begins executing
at the red node, then enters a loop (group of three nodes immediately
below the red node). On exiting the loop, there is a conditional
statement (group below the loop), and finally the program exits at the
blue node. This graph has 9 edges, 8 nodes, and 1 connected component,
so the cyclomatic complexity of the program is 9 - 8 + 2 * 1 = 3.</p>

<p><em>Source:</em>
<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Wikipedia</a></p>
</blockquote>

<p>The cyclomatic complexity of any piece of code should be minimized. This
can be achieved by avoiding branching, namely, whenever possible,
avoiding conditional statements and loops. Linear code is easier to read
and maintain, and provides less opportunities for bugs.</p>

<h3>Avoiding conditional statements</h3>

<p>One way to avoid conditional statements is to, whenever feasible, throw
exceptions instead of propagating errors through return values.</p>

<p>Here is an example of error code propagation through return values using
the Windows API&#39;s <code>HRESULT</code>:</p>
<div class="highlight"><pre><span></span><span class="n">HRESULT</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// Does some work and returns an HRESULT</span>
<span class="n">HRESULT</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w"> </span><span class="c1">// Does some work and returns an HRESULT</span>

<span class="n">HRESULT</span><span class="w"> </span><span class="nf">baz</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">HRESULT</span><span class="w"> </span><span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S_OK</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">hr</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">hr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">baz</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FAILED</span><span class="p">(</span><span class="n">hr</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">hr</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// Some more work here which might fail</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">hr</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SUCCEEDED</span><span class="p">(</span><span class="n">baz</span><span class="p">()))</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// :)</span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// :(</span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>This can be replaced with the more concise and much easier to read:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">();</span><span class="w"> </span><span class="c1">// Does some work, might throw</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">();</span><span class="w"> </span><span class="c1">// Does some work, might throw</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">baz</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">foo</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">baz</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// Some more work here which might fail (and throw)</span>
<span class="p">}</span><span class="w"></span>

<span class="k">try</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">baz</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">// :)</span>
<span class="p">}</span><span class="w"></span>
<span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// :(</span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Error code return values come from the old days when exceptions didn&#39;t
exist and make code harder to read. That being said, for C++
specifically, you should be careful about throwing exceptions across DLL
boundaries. In practice though, a lot of code in the shape of the above
example appears within the same executable for no good reason. If
cross-DLL boundary is a problem, I would actually recommend using
exceptions internally and switching to return codes at the public API
boundary.</p>

<p>Another way to avoid conditional statements is to use the <a href="https://en.wikipedia.org/wiki/Null_Object_pattern">Null Object
pattern</a> instead of
checking for null. For example, take an <code>IActivity</code> interface on which
we can log success or failure, and an <code>ActivityScope</code> which can retrieve
the current activity from a context:</p>
<div class="highlight"><pre><span></span><span class="k">interface</span><span class="w"> </span><span class="n">IActivity</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">void</span><span class="w"> </span><span class="nf">LogSuccess</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">void</span><span class="w"> </span><span class="nf">LogFailure</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">ActivityScope</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">IActivity</span><span class="w"> </span><span class="nf">GetCurrentActivity</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>With this implementation, all clients of the API have to make sure
<code>GetCurrentActivity()</code> returns an object as opposed to null. All callers
look like this:</p>
<div class="highlight"><pre><span></span><span class="n">ActivityScope</span><span class="w"> </span><span class="n">activityScope</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ActivityScope</span><span class="p">();</span><span class="w"></span>
<span class="n">activityScope</span><span class="p">.</span><span class="n">CreateActivity</span><span class="p">();</span><span class="w"></span>

<span class="p">...</span><span class="w"> </span><span class="c1">// Do a bunch of stuff</span>

<span class="kt">var</span><span class="w"> </span><span class="n">activity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">();</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">activity</span><span class="w"> </span><span class="p">!=</span><span class="w"> </span><span class="k">null</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">activity</span><span class="p">.</span><span class="n">LogSuccess</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>While there is a single <code>ActivityScope</code> implementation, there are
hundreds of calls to <code>GetCurrentActivity</code>, all coming with a boilerplate
null check. The Null Object alternative for this is to provide a
<code>NullActivity</code>, for which <code>LogSuccess</code> and <code>LogFailure</code> don&#39;t do
anything. <code>ActivityScope</code> can return <code>NullActivity</code> instead of null if
there is no <code>Activity</code> in the context:</p>
<div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">NullActivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IActivity</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">LogSuccess</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">LogFailure</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">ActivityScope</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">NullActivity</span><span class="w"> </span><span class="n">_nullActivity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NullActivity</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">IActivity</span><span class="w"> </span><span class="nf">GetCurrentActivity</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(!</span><span class="n">_context</span><span class="p">.</span><span class="n">HasCurrentActivity</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">_nullActivity</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">_context</span><span class="p">.</span><span class="n">GetActivity</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Now callers don&#39;t need to worry about getting back a null, and can use
the API like this:</p>
<div class="highlight"><pre><span></span><span class="n">activityScope</span><span class="p">.</span><span class="n">GetCurrentActivity</span><span class="p">().</span><span class="n">LogSuccess</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>Yet another way to reduce branching is when it used for mapping between
two types:</p>
<div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">==</span><span class="w"> </span><span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Foo string&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="p">==</span><span class="w"> </span><span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;Bar string&quot;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
</pre></div>

<p>A pattern like this (which can also take the form of a big switch/case
statement) can usually be replaced with indexing into an array or
looking up the corresponding value in a hash map:</p>
<div class="highlight"><pre><span></span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">&gt;</span><span class="w"> </span><span class="n">IdTypeToStringMap</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">IdType</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">&gt;()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">IdType</span><span class="p">.</span><span class="n">Foo</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Foo&quot;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">IdType</span><span class="p">.</span><span class="n">Bar</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Bar&quot;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">IdTypeToStringMap</span><span class="p">[</span><span class="n">a</span><span class="p">];</span><span class="w"></span>
</pre></div>

<p>This is, again, easier to maintain, since it is declarative - the
mapping is given as data (<code>IdTypeToStringMap</code>), not as code (long series
of if/else).</p>

<h3>Avoid loops</h3>

<p>This goes back to the C++ Seasoning talk, namely the <em>No Raw Loops</em>
guideline. Here&#39;s a C# example: given a list of numbers, we want to get
the square of all the odd numbers in the list.</p>
<div class="highlight"><pre><span></span><span class="kt">var</span><span class="w"> </span><span class="n">numbers</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">9</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">// Get the squares of all odd numbers</span>
</pre></div>

<p>One way to do this is to maintain a list of numbers, iterate over the
list, check if numbers are odd, and if so, square them and add them to
the list:</p>
<div class="highlight"><pre><span></span><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="w"> </span><span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">squares</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span><span class="w"></span>

<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">number</span><span class="w"> </span><span class="p">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">squares</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">number</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="n">number</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">squares</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">var</span><span class="w"> </span><span class="n">squares</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>A neater way to do this is to use a generator instead of manually
maintaining the list of squares:</p>
<div class="highlight"><pre><span></span><span class="c1">// Get the squares of all odd numbers</span>
<span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="w"> </span><span class="n">SquareOdds</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">number</span><span class="w"> </span><span class="p">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">yield</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="n">number</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">var</span><span class="w"> </span><span class="n">squares</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">SquareOdds</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>That being said, what I would actually recommend is using Linq:</p>
<div class="highlight"><pre><span></span><span class="c1">// Get the squares of all odd numbers</span>
<span class="kt">var</span><span class="w"> </span><span class="n">squares</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">numbers</span><span class="p">.</span><span class="w"></span>
<span class="w">                </span><span class="n">Where</span><span class="p">(</span><span class="n">number</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="p">!=</span><span class="w"> </span><span class="m">0</span><span class="p">).</span><span class="w"></span>
<span class="w">                </span><span class="n">Select</span><span class="p">(</span><span class="n">number</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">*</span><span class="w"> </span><span class="n">number</span><span class="p">);</span><span class="w"></span>
</pre></div>

<p>Fewer lines of code and no branching whatsoever<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>. <code>Where</code> and
<code>Select</code> are generic algorithms, and their arguments are the predicates
we use. This makes the intent of the code clear at a glance - we are
filtering the collection with a predicate (<code>number =&gt; number % 2 != 0</code>)
and applying a transformation to it with another predicate
(<code>number =&gt; number * number</code>). Also, the filtering and transformation
are library functions, so we can be fairly certain they work well, and
only need to worry about maintaining our predicates.</p>

<p>It might not look like a big deal in this simple made-up example, but as
code evolves, it becomes harder and harder to follow the iteration
logic, as the code gets littered with <code>break</code>, <code>continue</code>, and <code>return</code>
statements (see the Chrome example quoted in the Write Less Code
section).</p>

<p>Key takeaways:</p>

<ul>
<li>Try to keep functions linear (or as linear as possible)</li>
<li>Default to throwing instead of propagating errors up the call stack</li>
<li>Consider creating a null object when code is littered with null
checks</li>
<li>Separate algorithm logic from predicates to make the intent of the
code clear (in other words, no raw loops).</li>
</ul>

<h2>Notes on performance</h2>

<p>The most interesting question I was asked is what are the performance
implications of using an STL algorithm or Linq.</p>

<p>The default answer is, of course, you have to measure for your
particular case! Blanket statements cannot be made about performance, as
there are many factors involved: compiler, runtime, standard library,
OS, architecture, whether code is on a hot path or not, and so on and so
forth.</p>

<p>Still, my recommendation is to use the library algorithms and, only if
they become the bottleneck (which in most cases shouldn&#39;t happen), look
into replacing them with handcrafted code. Another thing to keep in mind
is that standard library authors know what they&#39;re doing, so it&#39;s very
likely that library code is already pretty well optimized. I ran a
simple wall clock benchmark for 1M iterations for some of the examples I
used throughout the presentation (both the handcrafted and the library
versions), and in all cases the code leveraging library functions ran
slightly faster.</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>Cyclomatic complexity of this is actually higher when computed by
looking at basic blocks (eg. from Visual Studio&#39;s <code>Analyze</code> menu),
since the compiler will automatically add a finally block to dispose
of the Linq-returned IEnumerables in case of exception. That being
said, I prefer compiler-generated complexity to developer-generated
complexity.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</article>
<nav>


<div id="next"><span><a href="../../../2016/01/07/clean-code-part-2.html">Clean Code - Part 2</a> »</span></div>

</nav>
<footer><span>By Vlad Rișcuția | <a href="../../../rss.xml">Subscribe</a> | <a href="../../../index.html">Index</a></span></footer>
</body>
</html>