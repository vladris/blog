<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Dependency Injection in C++ &mdash; Blog</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<link rel="stylesheet" href="../../../static/light.css" type="text/css">
<link rel="stylesheet" href="../../../static/pygments.css" type="text/css">
<link rel="shortcut icon" href="../../../static/icon.ico" />
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<header><span>July 06, 2016</span></header>
<article>
<h1>Dependency Injection in C++</h1>

<p>In this post, I will switch gears from functional C++ to object oriented
C++ and talk about dependency injection.</p>

<p>Let&#39;s start with a simple example: take a <code>Car</code> class with a <code>Drive()</code>
method. Let&#39;s say this class contains a <code>V8Engine</code> attribute with
<code>Start()</code> and <code>Stop()</code> methods. An initial implementation might look
like this:</p>

<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>

<span class="k">class</span><span class="w"> </span><span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Start</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>

<p><em>V8Engine.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;V8Engine.h&quot;</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>

<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>
<span class="cp">##include &quot;V8Engine.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Drive</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">V8Engine</span><span class="w"> </span><span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p><em>Car.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;Car.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Car::Drive</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// drive</span>
<span class="w">    </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<h2>Dependency Injection with Interfaces</h2>

<p>In the above example, <code>Car</code> is tightly coupled to <code>V8Engine</code>, meaning we
can&#39;t create a car without a concrete engine implementation. If we want
the ability to swap various engines or use a mock engine during testing,
we could reverse the dependency by creating an <code>IEngine</code> interface and
decoupling <code>Car</code> from the concrete <code>V8Engine</code> implementation. This way,
we only expose an <code>IEngine</code> interface and a factory function. <code>Car</code> can
work against that:</p>

<p><em>IEngine.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">IEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">IEngine</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeV8Engine</span><span class="p">();</span>
</pre></div>

<p><em>V8Engine.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;IEngine.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">V8Engine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">IEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* start the engine */</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* stop the engine */</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeV8Engine</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>
<span class="cp">##include &quot;IEngine.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">engine</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Drive</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p><em>Car.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;Car.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Car::Drive</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// drive</span>
<span class="w">    </span><span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<h2>Notes</h2>

<h3>A note on headers</h3>

<p>Headers simply get textually included in each compilation unit by the
<code>#include</code> directive. It is not mandatory to provide a header file for
each class declaration. If a class can be scoped to a single source
file, then it doesn&#39;t need a header declaration (for example the
<code>V8Engine</code> class above does not need a V8Engine.h header corresponding
to the V8Engine.cpp). It is also a good idea to have public headers and
internal headers: public headers contain the public API surface and can
be included by other parts of the system, while internal headers are
only used within the component and should not be included by external
code.</p>

<p>Default should be the least visible: try to keep everything inside the
cpp file (like V8Engine.cpp). If that is not enough, an internal header
might do. A declartion should be pulled into a public header only when
external components need to reference it.</p>

<h3>A note on interfaces</h3>

<p>It&#39;s a good idea to declare a default virtual destructor: if a deriving
type has a destructor, it won&#39;t get called if we store an upcast
pointer to the interface unless the interface declares a virtual
destructor. Note a destructor does not to be expicitly defined -
compiler might generate a default one.</p>

<p>MSVC compiler provides a <code>__declspec(novtable)</code><sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> custom attribute
which tells the compiler not to generate a vtable for pure abstract
classes. This reduces code size. Below is the <code>IEngine</code> declaration with
this attribute:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">__declspec</span><span class="p">(</span><span class="n">novtable</span><span class="p">)</span><span class="w"> </span><span class="n">IEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">IEngine</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>I won&#39;t include it in the code samples in this post, but it&#39;s worth
keeping in mind when working with MSVC.</p>

<h3>A note on factory functions</h3>

<p>When working with interfaces as opposed to concrete types, we use
factory functions to get object instances. Below is a possible naming
convention, taking object ownership into account:</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeFoo</span><span class="p">();</span>
<span class="n">IFoo</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">UseFoo</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">IFoo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetFoo</span><span class="p">();</span>
</pre></div>

<p>The first function, <code>MakeFoo</code>, returns a unique pointer, passing
ownership to the caller. Like in the example above, the <code>unqiue_ptr</code> can
be moved into the object, which ends up owning it. Use a Make when each
call creates a new instance.</p>

<p>The second function implies there already exists an <code>IFoo</code> object which
is owned by someone else, with the guarantee that it will outlive the
caller. In that case, there is no need for pointers and we can simply
return a reference to the object. This can be used, for example, for
singletons. Below is an example of a singleton <code>Engine</code>:</p>
<div class="highlight"><pre><span></span><span class="n">IEngine</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">UseEngine</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Engine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The third function, <code>GetFoo</code>, implies shared ownership - we get an
object that other objects might hold a reference to, but we don&#39;t have
the lifetime guarantee a singleton would give us, so we need to use a
shared pointer to make sure the object is kept alive long enough.</p>

<h2>Mocking</h2>

<p>Since <code>Car</code> now works with an <code>IEngine</code> interface, in test code we can
mock the engine:</p>

<p><em>Test.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;Car.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockEngine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">IEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* mock logic */</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* mock logic */</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Car</span><span class="w"> </span><span class="n">car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>

<p>We can also expose <code>Car</code> as a simple interface, hiding its
implementation details, in which case we would end up with the
following:</p>

<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>
<span class="cp">##include &quot;IEngine.h&quot;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ICar</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Drive</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ICar</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">engine</span><span class="p">);</span>
</pre></div>

<p><em>Car.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;ICar.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">engine</span><span class="p">)</span>
<span class="w">         </span><span class="o">:</span><span class="w"> </span><span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Drive</span><span class="p">()</span><span class="w"> </span><span class="k">override</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">         </span><span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">();</span>
<span class="w">         </span><span class="c1">// drive</span>
<span class="w">         </span><span class="n">m_engine</span><span class="o">-&gt;</span><span class="n">Stop</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>Test would become:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;ICar.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockEngine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">IEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* mock logic */</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* mock logic */</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">    </span><span class="c1">// Test ICar without a real Engine</span>
<span class="p">}</span>
</pre></div>

<p>Note this allows the caller to pass in any <code>IEngine</code>. We provide an
out-of-the-box <code>V8Engine</code> but other engines can be injected when <code>Car</code>
gets constructed. The headers IEngine.h and ICar.h are public per our
above defintion.</p>

<p>In general, it&#39;s great if we can get the rest of the component code and
unit tests to work against the interface. Sometimes though we might need
to know more about the actual implementation inside our component, even
if externally we only expose an interface. In that case, we can add an
internal Car.h header:</p>

<p><em>Car.h (internal)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>
<span class="cp">##include &quot;ICar.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">engine</span><span class="p">)</span>
<span class="w">         </span><span class="o">:</span><span class="w"> </span><span class="n">m_engine</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Drive</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p><em>Car.cpp</em> becomes:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;Car.h&quot;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Car::Drive</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// drive</span>
<span class="w">    </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeCar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IEngine</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">engine</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">engine</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<p>Now we can include the internal header, and, while not necessarily
recommended, we can cast <code>ICar</code> to <code>Car</code> inside the component:</p>
<div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">icar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeCar</span><span class="p">(</span><span class="n">MakeV8Engine</span><span class="p">());</span>
<span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">car</span><span class="p">);</span>
</pre></div>

<p>Another trick if needing access to internals (again, not something
necessarily recommended), is to make the unit test class testing <code>Car</code> a
friend of the <code>Car</code> class, in which case it can access its private
members.</p>

<p>In summary, with this approach we are able to:</p>

<ul>
<li>Hide implementation details in the .cpp files</li>
<li>Work against abstract interfaces</li>
<li>Inject dependencies during object construction</li>
</ul>

<h2>Dependecy Injection with Templates</h2>

<p>An alternative to the above is to use templates. In this case, we would
have to provide the implementation inside the header file, as code needs
to be available when templates get instantiated:</p>

<p><em>V8Engine.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>

<span class="k">class</span><span class="w"> </span><span class="nc">V8Engine</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Start</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>

<p><em>V8Engine.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;V8Engine.h&quot;</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Start</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// start the engine</span>
<span class="p">}</span>

<span class="n">V8Engine</span><span class="o">::</span><span class="n">Stop</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// stop the engine</span>
<span class="p">}</span>
</pre></div>

<p><em>Car.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Car</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Drive</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// drive</span>
<span class="w">        </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">TEngine</span><span class="w"> </span><span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p>Note <code>Car</code> is implemented in the header and <code>V8Engine</code> is also a
publicly visible header. Now we can create an instance of <code>Car</code> like
this:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;V8Engine.h&quot;</span>
<span class="cp">##include &quot;Car.h&quot;</span>

<span class="p">...</span>

<span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">car</span><span class="p">;</span>
</pre></div>

<p>Mocking the engine in test code would look like this:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;Car.h&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MockEngine</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* mock logic */</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* mock logic */</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Test</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Car</span><span class="o">&lt;</span><span class="n">MockEngine</span><span class="o">&gt;</span><span class="w"> </span><span class="n">car</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Test Car without a real Engine</span>
<span class="p">}</span>
</pre></div>

<p>With this approach we are able to:</p>

<ul>
<li>Inject dependencies during template instantiation</li>
<li>No need for virtual calls (note <code>TEngine</code> is not an interface, so
calls can be resolved at compile-time)</li>
<li><code>Car&lt;T&gt;</code> can be default-constructed</li>
</ul>

<p>A drawback here is we expose the implementation details of <code>Car</code> inside
the header file and we have to make this publicly visible.</p>

<h2>Hybrid Approach</h2>

<p>We can use a hybrid approach if we don&#39;t need an externally injected
<code>Engine</code>. Say our component provides a <code>V8Engine</code>, a <code>V6Engine</code>, and we
have a <code>MockEngine</code> used during testing. We have the same
componentization requirements but don&#39;t need to expose all the details
to consumers. In that case we could have something like this:</p>

<p><em>ICar.h (publicly visible)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ICar</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Drive</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">ICar</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeV8Car</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeV6Car</span><span class="p">();</span>
</pre></div>

<p><em>Car.h (internal)</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##pragma once</span>
<span class="cp">##include &quot;ICar.h&quot;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">TEngine</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ICar</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Drive</span><span class="p">()</span><span class="w"> </span><span class="k">override</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// drive</span>
<span class="w">        </span><span class="n">m_engine</span><span class="p">.</span><span class="n">Stop</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">TEngine</span><span class="w"> </span><span class="n">m_engine</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>

<p><em>Car.cpp</em>:</p>
<div class="highlight"><pre><span></span><span class="cp">##include &quot;Car.h&quot;</span>
<span class="cp">##include &quot;V8Engine.h&quot;</span>
<span class="cp">##include &quot;V6Engine.h&quot;</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeV8Car</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V8Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ICar</span><span class="o">&gt;</span><span class="w"> </span><span class="n">MakeV6Car</span><span class="p">();</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&lt;</span><span class="n">V6Engine</span><span class="o">&gt;&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>Test would remain the same as in the example above, where we worked
against a <code>Car</code> type (not an <code>ICar</code>) which we instantiate with a
<code>MockEngine</code>.</p>

<p>With this approach:</p>

<ul>
<li>Our external API is an interface</li>
<li>Internally we still inject the dependency using a template</li>
</ul>

<p>With this approach, we do have an interface and virtual calls for <code>Car</code>
but not for <code>TEngine</code> types. One drawback with this approach is that
consumers cannot inject their own Engine type: we can only create cars
with engines that are known within our component.</p>

<h2>Summary</h2>

<p>We decoupled <code>Car</code> from <code>V8Engine</code> and looked at three ways of injecting
the dependency:</p>

<ul>
<li>Using interfaces, where dependency is injected at runtime during
object creation</li>
<li>Using templates, where dependency is injected at compile-time during
template instantiation</li>
<li>A hybrid approach which uses templates internally but exposes only
interfaces publicly</li>
</ul>

<p>Each of these approaches has pros and cons, the tradeoffs mostly being
around encapsulation (how much of the component code we expose
publicly), runtime (templates are instantiated at compile-time so no
virtual calls etc.), type constraints (with templates we don&#39;t require
engines to implement a particular <code>IEngine</code> interface), and flexibility
(with the hybrid approach we can&#39;t inject an external engine, we can
only use what the component has available internally).</p>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>For more details on <code>novtable</code>, see
<a href="https://msdn.microsoft.com/en-us/library/k13k85ky.aspx">MSDN</a>.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

</article>
<nav>

<div id="prev"><span>« <a href="../../../2016/04/24/abusing-maps.html">(Ab)using Maps</a></span></div>


<div id="next"><span><a href="../../../2016/08/17/concepts-and-modules.html">Concepts and Modules</a> »</span></div>

</nav>
<footer><span>By <a href="https://vladris.com">Vlad Rișcuția</a> | <a href="../../../rss.xml">Subscribe</a> | <a href="../../../index.html">Index</a></span></footer>
</body>
</html>